#include "config.h"

extern std::atomic<bool> aiming;
extern std::mutex configMutex;

MouseThread::MouseThread(
    int resolution,
    float kp_x,
    float ki_x,
    float kd_x,
    float kp_y,
    float ki_y,
    float kd_y,
    bool auto_shoot,
    float bScope_multiplier,
    float norecoil_ms,
    SerialConnection *serialConnection,
    GhubMouse *gHub) : tracking_errors(false)
{
    initializeScreen(resolution, auto_shoot, bScope_multiplier, norecoil_ms);
    pid_controller = std::make_unique<PIDController2D>(kp_x, ki_x, kd_x, kp_y, ki_y, kd_y);
    initializeInputMethod(serialConnection, gHub);
}

void MouseThread::initializeScreen(int resolution, bool auto_shoot, float bScope_multiplier, float norecoil_ms)
{
    this->screen_width = static_cast<float>(resolution);
    this->screen_height = static_cast<float>(resolution); 
    this->auto_shoot = auto_shoot;
    this->bScope_multiplier = bScope_multiplier;
    this->norecoil_ms = norecoil_ms; 
    this->center_x = screen_width / 2.0f;
    this->center_y = screen_height / 2.0f;

    const float SENSITIVITY_FACTOR = 0.05f; // Example: Adjust this base sensitivity
    float base_scale_x = SENSITIVITY_FACTOR;
    float base_scale_y = SENSITIVITY_FACTOR;

    if (this->bScope_multiplier > 1.0f) {
        this->move_scale_x = base_scale_x / this->bScope_multiplier;
        this->move_scale_y = base_scale_y / this->bScope_multiplier;
    } else {
        this->move_scale_x = base_scale_x;
        this->move_scale_y = base_scale_y;
    }

    this->last_recoil_compensation_time = std::chrono::steady_clock::now();
}

void MouseThread::updateConfig(
    int resolution,
    float kp_x,
    float ki_x,
    float kd_x,
    float kp_y,
    float ki_y,
    float kd_y,
    bool auto_shoot,
    float bScope_multiplier,
    float norecoil_ms
    )
{
    initializeScreen(resolution, auto_shoot, bScope_multiplier, norecoil_ms);
    pid_controller->updateSeparatedParameters(kp_x, ki_x, kd_x, kp_y, ki_y, kd_y);
}

Eigen::Vector2f MouseThread::calculateMovement(const Eigen::Vector2f &target_pos)
{
    const float local_center_x = center_x;
    const float local_center_y = center_y;

    float target_center_x = target_pos.x() + target_pos.x() * 0.5f;
    float target_center_y = target_pos.y() + target_pos.y() * 0.5f;

    float error_x = target_center_x - local_center_x;
    float error_y = target_center_y - local_center_y;

    if (tracking_errors)
    {
        // ... existing code ...
    }

    return Eigen::Vector2f(error_x, error_y);
}

void MouseThread::moveMouse(const AimbotTarget &target)
{
    const float local_center_x = center_x;
    const float local_center_y = center_y;

    float target_center_x = target.x + target.w * 0.5f;
    float target_center_y;
    constexpr int HEAD_CLASS_ID = 0; // Assuming 0 is the class ID for head

    {
        std::lock_guard<std::mutex> lock(configMutex);
        if (!config.disable_headshot && target.classId == HEAD_CLASS_ID) {
            target_center_y = target.y + target.h * config.head_y_offset;
        } else {
            target_center_y = target.y + target.h * config.body_y_offset;
        }
    }

    float error_x = target_center_x - local_center_x;
    float error_y = target_center_y - local_center_y;

    if (tracking_errors)
    {
        // ... existing code ...
    }
} 