*** Begin Patch
*** Update File: needaimbot/cuda/unified_graph_pipeline.cu
@@
-bool UnifiedGraphPipeline::executeFrame(FrameFailureReason* outReason, cudaStream_t stream) {
+bool UnifiedGraphPipeline::executeFrame(FrameFailureReason* outReason, cudaStream_t stream) {
+    // Strict serial pipeline contract (design intent):
+    //  1) Capture frame N
+    //  2) Process frame N (GPU)
+    //  3) Emit mouse movement for frame N (host callback)
+    //  4) Only after that input is reflected on screen, begin capture for frame N+1
+    //
+    // We enforce (4) by recording the QPC at input injection time in
+    // enqueueFrameCompletionCallback() and gating the next capture in
+    // scheduleNextFrameCapture() via WaitForNewFrameSince(m_pendingInputQpc, timeout).
+    // Do NOT overlap the next capture with current graph execution.
@@
-        // Schedule next capture if nothing in flight
-        (void)scheduleNextFrameCapture(false);
+        // Schedule capture for the current frame (N). The next frame (N+1)
+        // will be scheduled in the next executeFrame() iteration after the
+        // QPC gate confirms the previous input has been presented.
+        (void)scheduleNextFrameCapture(false);
@@
-        // Mark frame as consumed; the next capture will update the ring
+        // Mark this frame as consumed. Next executeFrame() will schedule the
+        // next capture after the QPC gate.
         m_captureState.store(CaptureState::CONSUMED, std::memory_order_release);
*** End Patch
